<audio id="audioPlay" controls></audio>
<input type="file" id="fileInput">
<hr>
<canvas width="256" height="256" id="visualizer">
<script>const audioPlayer = document.getElementById("audioPlay"), s = document.getElementById("visualizer").getContext("2d");
class AudioExporter {
    constructor(audioData, sampleRate, channels) {
        this.audioData = audioData;
        this.sampleRate = sampleRate;
        this.channels = channels;
    }
    convertToWav() {
        const numChannels = this.channels, len = this.audioData.length;
        const len2 = len;
        const buffer = new ArrayBuffer(44 + len2);
        const view = new DataView(buffer);
        this.writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + len2, true);
        this.writeString(view, 8, 'WAVE');
        this.writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, this.sampleRate, true);
        view.setUint32(28, this.sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 8, true);
        this.writeString(view, 36, 'data');
        view.setUint32(40, len2, true);
        let offset = 44;
        for (let i = 0; i < len; i++) {
            view.setInt8(offset, this.audioData[i], true);
            offset++;
        }
        return new Blob([view], { type: 'audio/wav' });
    }
    writeString(view, offset, string) {
        for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
        }
    }
};

let audioData, exporter;

document.getElementById("fileInput").addEventListener('change', (event) => {
    const file = event.target.files[0]; // Get the first file
    if (file) {
        const reader = new FileReader();
        // When the file is successfully read (why does this sound like a meme?)
        reader.onload = function(e) {
            const arrayBuffer = e.target.result, mode = parseFloat(prompt("What mode should be used for the interpretation process? 0 = basic interpretation: file data is interpeted as audio in the way it was organized.")) >>> 0;
            if (mode === 0) {
                audioData = new Int8Array(arrayBuffer); // LOOK, MOM!! I OPTIMIZED MY DATA INTERPRETATION STEPS!!! ISNT THAT COOL????
            }
            exporter = new AudioExporter(audioData, Number(prompt("Enter in the sample rate of the audio (48000 will be the default if invalid input, or input not received).") || 48000), 1);
            if (audioPlayer.src) URL.revokeObjectURL(audioPlayer.src);
            audioPlayer.src = URL.createObjectURL(exporter.convertToWav());
            alert("WARNING: THE RESULT OF THE AUDIO MAY CONTAIN VERY HIGH FREQUENCIES FOR DATA THAT MAY VARY A LOT!");
        };
        // Read the file as an ArrayBuffer
        alert("The file has been uploaded to the tool (not sent to the internet). Pressing OK may begin the reading process."), reader.readAsArrayBuffer(file);
    }
});
function update() {
    s.fillStyle = "rgba(0,0,0,1)";
    s.fillRect(0, 0, 256, 256);
    if (audioData && audioData.length !== 0) {
        const destination = Math.round(audioPlayer.currentTime * exporter.sampleRate);
        let i = 0, rgba;
        for (let x = 0; x < 16; x++) {
            for (let y = 0; y < 16; y++) {
                const z = destination + x * 3 + y * 64;
                const b = audioData[z] + 32768;
                rgba = "rgb(" + (audioData[z] + 32768) + "," + (audioData[z + 1] + 32768) + "," + (audioData[z + 2] + 32768) + ")";
                s.fillStyle = rgba;
                s.fillRect(x * 16, y * 16, 16, 16);
            }
        }
    }
    requestAnimationFrame(()=>update());
}
update();
</script>
